/*	SCCS Id: @(#)makedefs.c	3.4	2002/08/14	*/
/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
/* Copyright (c) M. Stephenson, 1990, 1991.			  */
/* Copyright (c) Dean Luick, 1990.				  */
/* NetHack may be freely redistributed.  See license for details. */

#define MAKEDEFS_C	/* use to conditionally include file sections */
/* #define DEBUG */	/* uncomment for debugging info */

#include "config.h"
#include "permonst.h"
#include "objclass.h"
#include "monsym.h"
#include "artilist.h"
#include "mondata.h"
#include "dungeon.h"
#include "obj.h"
#include "monst.h"
#include "you.h"
#include "flag.h"
#include "dlb.h"

/* version information */
#include "patchlevel.h"

#ifdef MAC
# ifdef MAC_MPW
#  define MPWTOOL
#  include <CursorCtl.h>
#  include <string.h>
#  include <ctype.h>
# else		/* MAC without MPWTOOL */
#  define MACsansMPWTOOL
# endif /* MAC_MPW */
#endif /* MAC */

#ifndef MPWTOOL
# define SpinCursor(x)
#endif

#if !defined(AMIGA) || defined(AZTEC_C)
#define rewind(fp) fseek((fp),0L,SEEK_SET)	/* guarantee a return value */
#endif

#if defined(UNIX) && !defined(LINT) && !defined(GCC_WARN)
static	const char	SCCS_Id[] = "@(#)makedefs.c\t3.4\t2002/02/03";
#endif

	/* names of files to be generated */
#define DATE_FILE	"date.h"
#define MONST_FILE	"pm.h"
#define ONAME_FILE	"onames.h"
#define VERINFO_FILE	"verinfo.h"
#ifndef NH_OPTIONS_FILE
#define OPTIONS_FILE	"options"
#else
#define OPTIONS_FILE    NH_OPTIONS_FILE
#endif
#define ORACLE_FILE	"oracles"
#define DATA_FILE	"data"
#define RUMOR_FILE	"rumors"
#define DGN_I_FILE	"dungeon.def"
#define DGN_O_FILE	"dungeon.pdf"
#define DGN_I_FILE2	"dungeon2.def"
#define DGN_O_FILE2	"dungeon2.pdf"
#define DGN_I_FILE3	"dungeon3.def"
#define DGN_O_FILE3	"dungeon3.pdf"
#define DGN_I_FILE4	"dungeon4.def"
#define DGN_O_FILE4	"dungeon4.pdf"
#define DGN_I_FILE5	"dungeon5.def"
#define DGN_O_FILE5	"dungeon5.pdf"
#define DGN_I_FILE6	"dungeon6.def"
#define DGN_O_FILE6	"dungeon6.pdf"
#define DGN_I_FILE7	"dungeon7.def"
#define DGN_O_FILE7	"dungeon7.pdf"
#define DGN_I_FILE8	"dungeon8.def"
#define DGN_O_FILE8	"dungeon8.pdf"
#define MON_STR_C	"monstr.c"
#define QTXT_I_FILE	"quest.txt"
#define QTXT_O_FILE	"quest.dat"
#define VIS_TAB_H	"vis_tab.h"
#define VIS_TAB_C	"vis_tab.c"
/*WAC filename*/
/*input*/
#define FILE_H          "file.h"
/*output*/
#define FILENAME_H      "filename.h"

	/* locations for those files */
#ifdef AMIGA
# define FILE_PREFIX
# define INCLUDE_TEMPLATE	"NH:include/t.%s"
# define SOURCE_TEMPLATE	"NH:src/%s"
# define DGN_TEMPLATE		"NH:dat/%s"  /* where dungeon.pdf file goes */
# define DATA_TEMPLATE		"NH:slib/%s"
# define DATA_IN_TEMPLATE	"NH:dat/%s"
#else
# if defined(MAC) && !defined(__MACH__)
	/* MacOS 9 or earlier */
#   define INCLUDE_TEMPLATE	":include:%s"
#   define SOURCE_TEMPLATE	":src:%s"
#   define DGN_TEMPLATE		":dat:%s"  /* where dungeon.pdf file goes */
#   define DATA_TEMPLATE        "::lib:%s"
#   define DATA_IN_TEMPLATE	":dat:%s"
# else /* MAC */
#  ifdef OS2
#   define INCLUDE_TEMPLATE	"..\\include\\%s"
#   define SOURCE_TEMPLATE	"..\\src\\%s"
#   define DGN_TEMPLATE		"..\\dat\\%s"  /* where dungeon.pdf file goes */
#   define DATA_TEMPLATE	"..\\dat\\%s"
#   define DATA_IN_TEMPLATE	"..\\dat\\%s"
#  else /* OS2 */
#   define INCLUDE_TEMPLATE	"../include/%s"
#   define SOURCE_TEMPLATE	"../src/%s"
#   define DGN_TEMPLATE		"../dat/%s"  /* where dungeon.pdf file goes */
#   define DATA_TEMPLATE	"../dat/%s"
#   define DATA_IN_TEMPLATE	"../dat/%s"
#  endif /* OS2 */
# endif /* MAC */
#endif  /* AMIGA */

static const char
    *Dont_Edit_Code =
	"/* This source file is generated by 'makedefs'.  Do not edit. */\n",
    *Dont_Edit_Data =
	"#\tThis data file is generated by 'makedefs'.  Do not edit. \n";

static struct version_info version;

#ifdef MAC_MPW
static const char *data_template()
{
	static char *result;
	if (result)
		return result;
	result = malloc(strlen(getenv("ObjDir"))+3);
	strcpy(result, getenv("ObjDir"));
	strcat(result, "%s");
	return result;
}
#endif

/* definitions used for vision tables */
#define TEST_WIDTH  COLNO
#define TEST_HEIGHT ROWNO
#define BLOCK_WIDTH (TEST_WIDTH + 10)
#define BLOCK_HEIGHT TEST_HEIGHT	/* don't need extra spaces */
#define MAX_ROW (BLOCK_HEIGHT + TEST_HEIGHT)
#define MAX_COL (BLOCK_WIDTH + TEST_WIDTH)
/* Use this as an out-of-bound value in the close table.  */
#define CLOSE_OFF_TABLE_STRING "99"	/* for the close table */
#define FAR_OFF_TABLE_STRING "0xff"	/* for the far table */

#define sign(z) ((z) < 0 ? -1 : ((z) ? 1 : 0))
#ifdef VISION_TABLES
static char xclear[MAX_ROW][MAX_COL];
#endif
/*-end of vision defs-*/

static char     in_line[256], filename[600];

#ifdef FILE_PREFIX
		/* if defined, a first argument not starting with - is
		 * taken as a text string to be prepended to any
		 * output filename generated */
char *file_prefix="";
#endif

#ifdef MACsansMPWTOOL
int main(void);
#else
int main(int,char **);
#endif
void do_makedefs(char *);
void do_objs(void);
void do_data(void);
void do_dungeon(void);
void do_date(int);
void do_options(void);
void do_monstr(void);
void do_permonst(void);
void do_questtxt(void);
void do_rumors(void);
void do_oracles(void);
void do_vision(void);
/*WAC filenames*/
void do_filenames(void);

extern void monst_globals_init(void);		/* monst.c */
extern void objects_init(void);	/* objects.c */

static void make_version(void);
static char *version_string(char *);
static char *version_id_string(char *,const char *);
static char *xcrypt(const char *);
static int check_control(char *);
static char *without_control(char *);
static boolean d_filter(char *);
static boolean h_filter(char *);
static boolean ranged_attk(struct permonst*);
static int mstrength(struct permonst *);
static void build_savebones_compat_string(void);

static boolean qt_comment(char *);
static boolean qt_control(char *);
static int get_hdr(char *);
static boolean new_id(char *);
static boolean known_msg(int,int);
static void new_msg(char *,int,int);
static void do_qt_control(char *);
static void do_qt_text(char *);
static void adjust_qt_hdrs(void);
static void put_qt_hdrs(void);

#ifdef VISION_TABLES
static void H_close_gen(void);
static void H_far_gen(void);
static void C_close_gen(void);
static void C_far_gen(void);
static int clear_path(int,int,int,int);
#endif

static char *tmpdup(const char *);
static char *limit(char *,int);
static char *eos(char *);

/*Stolen from hacklib.c*/
static char *lcase(char *);
static char *ucase(char *);

/* input, output, tmp */
static FILE *ifp, *ofp, *tfp;

#if defined(__BORLANDC__) && !defined(_WIN32)
extern unsigned _stklen = STKSIZ;
#endif


#ifdef MACsansMPWTOOL
int
main(void)
{
    const char *def_options = "odefmvpqrhz";
    char buf[100];
    int len;

    printf("Enter options to run: [%s] ", def_options);
    fflush(stdout);
    fgets(buf, 100, stdin);
    len = strlen(buf);
    if (len <= 1)
	strcpy(buf, def_options);
    else
	buf[len-1] = 0;			/* remove return */

    do_makedefs(buf);
    exit(EXIT_SUCCESS);
    return 0;
}

#else /* ! MAC */

int
main(argc, argv)
int	argc;
char	*argv[];
{
	if ( (argc != 2)
#ifdef FILE_PREFIX
		&& (argc != 3)
#endif
	) {
	    fprintf(stderr, "Bad arg count (%d).\n", argc-1);
	    (void) fflush(stderr);
	    return 1;
	}
#ifdef FILE_PREFIX
	if(argc >=2 && argv[1][0]!='-'){
	    file_prefix=argv[1];
	    argc--;argv++;
	}
#endif
	do_makedefs(&argv[1][1]);
	exit(EXIT_SUCCESS);
	/*NOTREACHED*/
	return 0;
}

#endif

void
do_makedefs(options)
char	*options;
{
	boolean more_than_one;

	/* Note:  these initializers don't do anything except guarantee that
		we're linked properly.
	*/
	monst_globals_init();
	objects_init();

	/* construct the current version number */
	make_version();

	more_than_one = strlen(options) > 1;
	while (*options) {
	    if (more_than_one)
		fprintf(stderr, "makedefs -%c\n", *options);

	    switch (*options) {
		case 'o':
		case 'O':	do_objs();
				break;
		case 'd':
		case 'D':	do_data();
				break;
		case 'e':
		case 'E':	do_dungeon();
				break;
/*WAC do filenames*/
                case 'f':
                case 'F':       do_filenames();
                                break;
		case 'm':
		case 'M':	do_monstr();
				break;
		case 'v':
		case 'V':	do_date(0);
				do_options();
				break;
		case 'w':
		case 'W':	do_date(1);
				break;
		case 't':
		case 'T':	do_options();
				break;
		case 'a':
		case 'A':	do_date(0);
				break;
		case 'p':
		case 'P':	do_permonst();
				break;
		case 'q':
		case 'Q':	do_questtxt();
				break;
		case 'r':
		case 'R':	do_rumors();
				break;
		case 'h':
		case 'H':	do_oracles();
				break;
		case 'z':
		case 'Z':	do_vision();
				break;
		default:	fprintf(stderr,	"Unknown option '%c'.\n",
					*options);
				(void) fflush(stderr);
				exit(EXIT_FAILURE);
		
	    }
	    options++;
	}
	if (more_than_one) fprintf(stderr,"%s", "Completed.\n");	/* feedback */

}


/* trivial text encryption routine which can't be broken with `tr' */
static
char *xcrypt(str)
const char *str;
{				/* duplicated in src/hacklib.c */
	static char buf[BUFSZ];
	register const char *p;
	register char *q;
	register int bitmask;

	for (bitmask = 1, p = str, q = buf; *p; q++) {
		*q = *p++;
		if (*q & (32|64)) *q ^= bitmask;
		if ((bitmask <<= 1) >= 32) bitmask = 1;
	}
	*q = '\0';
	return buf;
}

void
do_rumors()
{
	char    *infile;
	long	true_rumor_size;

	infile = malloc(strlen(DATA_IN_TEMPLATE) - 2 + strlen(RUMOR_FILE) + 5);
	filename[0]='\0';
#ifdef FILE_PREFIX
	strcat(filename,file_prefix);
#endif
	sprintf(eos(filename), DATA_TEMPLATE, RUMOR_FILE);
	if (!(ofp = fopen(filename, WRTMODE))) {
		perror(filename);
		exit(EXIT_FAILURE);
	}
	fprintf(ofp,"%s",Dont_Edit_Data);

	sprintf(infile, DATA_IN_TEMPLATE, RUMOR_FILE);
	strcat(infile, ".tru");
	if (!(ifp = fopen(infile, RDTMODE))) {
		perror(infile);
		fclose(ofp);
		unlink(filename);	/* kill empty output file */
		exit(EXIT_FAILURE);
	}

	/* get size of true rumors file */
#ifndef VMS
	(void) fseek(ifp, 0L, SEEK_END);
	true_rumor_size = ftell(ifp);
#else
	/* seek+tell is only valid for stream format files; since rumors.%%%
	   might be in record format, count the actual data bytes instead.
	 */
	true_rumor_size = 0;
	while (fgets(in_line, sizeof in_line, ifp) != 0)
		true_rumor_size += strlen(in_line);	/* includes newline */
#endif /* VMS */
	fprintf(ofp,"%06lx\n", true_rumor_size);
	(void) fseek(ifp, 0L, SEEK_SET);

	/* copy true rumors */
	while (fgets(in_line, sizeof in_line, ifp) != 0)
		(void) fputs(xcrypt(in_line), ofp);

	fclose(ifp);

	sprintf(infile, DATA_IN_TEMPLATE, RUMOR_FILE);
	strcat(infile, ".fal");
	if (!(ifp = fopen(infile, RDTMODE))) {
		perror(infile);
		fclose(ofp);
		unlink(filename);	/* kill incomplete output file */
		exit(EXIT_FAILURE);
	}

	/* copy false rumors */
	while (fgets(in_line, sizeof in_line, ifp) != 0)
		(void) fputs(xcrypt(in_line), ofp);

	fclose(ifp);
	fclose(ofp);
	free(infile);
	return;
}

/*
 * 3.4.1: way back in 3.2.1 `flags.nap' became unconditional but
 * TIMED_DELAY was erroneously left in VERSION_FEATURES and has
 * been there up through 3.4.0.  Simply removing it now would
 * break save file compatibility with 3.4.0 files, so we will
 * explicitly mask it out during version checks.
 * This should go away in the next version update.
 */
#define IGNORED_FEATURES	( 0L \
				| (1L << 23)	/* TIMED_DELAY */ \
				)

static void
make_version()
{
	register int i;

	/*
	 * integer version number
	 */
	version.incarnation = ((unsigned long)VERSION_MAJOR << 24) |
				((unsigned long)VERSION_MINOR << 16) |
				((unsigned long)PATCHLEVEL << 8) |
#ifdef EDITLEVEL
				((unsigned long)EDITLEVEL);
#else
				((unsigned long)0);
#endif
	/*
	 * encoded feature list
	 * Note:  if any of these magic numbers are changed or reassigned,
	 * EDITLEVEL in patchlevel.h should be incremented at the same time.
	 * The actual values have no special meaning, and the category
	 * groupings are just for convenience.
	 */
	version.feature_set = (unsigned long)(0L
		/* levels and/or topology (0..3) */
#ifdef REINCARNATION
			| (1L <<  1)
#endif
			| (1L <<  2)
		/* monsters (4..7) */
			| (1L <<  6)
#ifdef MAIL
			| (1L <<  7)
#endif
		/* objects (8..15) */
			| (1L <<  9)
			| (1L << 10)
			| (1L << 11)
#ifdef GOLDOBJ
			| (1L << 12)
#endif
			| (1L << 13)
			| (1L << 14)
			| (1L << 15)
		/* flag bits and/or other global variables (16..26) */
#ifdef DISPLAY_LAYERS
			| (1L << 16)
#endif
#ifdef TEXTCOLOR
			| (1L << 17)
#endif
#ifdef INSURANCE
			| (1L << 18)
#endif
			| (1L << 19)
		/* data format [COMPRESS excluded] (27..31) */
#ifdef ZEROCOMP
			| (1L << 27)
#endif
#ifdef RLECOMP
			| (1L << 28)
#endif
			);
	/*
	 * Value used for object & monster sanity check.
	 *    (NROFARTIFACTS<<24) | (NUM_OBJECTS<<12) | (NUMMONS<<0)
	 */
	for (i = 1; artifact_names[i]; i++) continue;
        version.entity_count = (unsigned long) (i - 1);
	for (i = 1; objects[i].oc_class != ILLOBJ_CLASS; i++) continue;
        version.entity_count = (version.entity_count << 12) | (unsigned long) i;
	for (i = 0; mons[i].mlet; i++) continue;
        version.entity_count = (version.entity_count << 12) | (unsigned long) i;
	/*
	 * Value used for compiler (word size/field alignment/padding) check.
	 */
	version.struct_sizes = (((unsigned long)sizeof (struct flag)  << 24) |
				((unsigned long)sizeof (struct obj)   << 17) |
				((unsigned long)sizeof (struct monst) << 10) |
				((unsigned long)sizeof (struct you)));
	return;
}

static char *
version_string(outbuf)
char *outbuf;
{
    sprintf(outbuf, "%d.%d.%d", VERSION_MAJOR, VERSION_MINOR, PATCHLEVEL);
#ifdef EDITLEVEL
    sprintf(eos(outbuf), "E%d", EDITLEVEL);
#ifdef FIXLEVEL
    sprintf(eos(outbuf), "F%d", FIXLEVEL);
#endif
#endif
    return outbuf;
}

/* WAC use DEF_GAME_NAME */
static char *
version_id_string(outbuf, build_date)
char *outbuf;
const char *build_date;
{
    char subbuf[64], versbuf[64];
    subbuf[0] = '\0';
#ifdef PORT_SUB_ID
    subbuf[0] = ' ';
    strcpy(&subbuf[1], PORT_SUB_ID);
#endif
#if defined(ALPHA)
    strcat(subbuf, " Alpha");
#elif defined(BETA)
    strcat(subbuf, " Beta");
#endif

    if (getenv("VCS_DESCRIPTION") && getenv("VCS_DESCRIPTION")[0])
        sprintf(outbuf, "%s %s%s Version %s (%s) - last build %s.",
                PORT_ID, DEF_GAME_NAME, subbuf, version_string(versbuf),
                getenv("VCS_DESCRIPTION"), build_date);
    else
        sprintf(outbuf, "%s %s%s Version %s - last build %s.",
                PORT_ID, DEF_GAME_NAME, subbuf, version_string(versbuf),
                build_date);

    return outbuf;
}

void
do_date(verinfo)
int verinfo;
{
	long clocktim = 0;
	char *c,  *cbuf, buf[BUFSZ];
	const char *ul_sfx;

	cbuf = malloc(600);
	filename[0]='\0';
#ifdef FILE_PREFIX
	strcat(filename,file_prefix);
#endif
	if (verinfo)
		sprintf(eos(filename), INCLUDE_TEMPLATE, VERINFO_FILE);
	else
		sprintf(eos(filename), INCLUDE_TEMPLATE, DATE_FILE);
	if (!(ofp = fopen(filename, WRTMODE))) {
		perror(filename);
		exit(EXIT_FAILURE);
	}
	fprintf(ofp,"%s","/*\tSCCS Id: @(#)date.h\t3.4\t2002/02/03 */\n\n");
	fprintf(ofp,"%s",Dont_Edit_Code);

#ifdef KR1ED
	(void) time(&clocktim);
	strcpy(cbuf, ctime(&clocktim));
#else
	(void) time((time_t *)&clocktim);
	strcpy(cbuf, ctime((time_t *)&clocktim));
#endif
	for (c = cbuf; *c; c++) if (*c == '\n') break;
	*c = '\0';	/* strip off the '\n' */
#ifdef NHSTDC
	ul_sfx = "UL";
#else
	ul_sfx = "L";
#endif
	if (!verinfo) {
		fprintf(ofp,"#define BUILD_DATE \"%s\"\n", cbuf);
		fprintf(ofp,"#define BUILD_TIME (%ldL)\n", clocktim);
	}
	fprintf(ofp,"%s","\n");
	fprintf(ofp,"#define VERSION_NUMBER 0x%08lx%s\n",
		version.incarnation, ul_sfx);
	fprintf(ofp,"#define VERSION_FEATURES 0x%08lx%s\n",
		version.feature_set, ul_sfx);
#ifdef IGNORED_FEATURES
	fprintf(ofp,"#define IGNORED_FEATURES 0x%08lx%s\n",
		(unsigned long) IGNORED_FEATURES, ul_sfx);
#endif
	fprintf(ofp,"#define VERSION_SANITY1 0x%08lx%s\n",
		version.entity_count, ul_sfx);
	fprintf(ofp,"#define VERSION_SANITY2 0x%08lx%s\n",
		version.struct_sizes, ul_sfx);
	fprintf(ofp,"%s","\n");
	fprintf(ofp,"#define VERSION_STRING \"%s\"\n", version_string(buf));
	if (!verinfo)
		fprintf(ofp,"#define VERSION_ID \\\n \"%s\"\n",
			version_id_string(buf, cbuf));
#ifdef AMIGA
	{
	struct tm *tm = localtime((time_t *) &clocktim);
	fprintf(ofp,"%s","#define AMIGA_VERSION_STRING ");
	fprintf(ofp,"\"\\0$VER: NetHack %d.%d.%d (%d.%d.%d)\"\n",
		VERSION_MAJOR, VERSION_MINOR, PATCHLEVEL,
		tm->tm_mday, tm->tm_mon+1, tm->tm_year+1900);
	}
#endif
	fclose(ofp);
	free(cbuf);
	return;
}

static char save_bones_compat_buf[BUFSZ];

static void
build_savebones_compat_string()
{
#ifdef VERSION_COMPATIBILITY
	unsigned long uver = VERSION_COMPATIBILITY;
#else
	unsigned long uver = 0;
#endif
	char editsuffix[20], ueditsuffix[20];
	/* Add edit level suffices if either EDITLEVEL is defined, or
	 * the first level we are compatible with was not edit level 0.
	 */
#ifdef EDITLEVEL
	sprintf(editsuffix, "E%d", EDITLEVEL);
	sprintf(ueditsuffix, "E%lu", uver & 0x000000FFL);
#else
	if (uver & 0x000000FFL) {
	    strcpy(editsuffix, "E0");
	    sprintf(ueditsuffix, "E%lu", uver & 0x000000FFL);
	} else {
	    editsuffix[0] = 0;
	    ueditsuffix[0] = 0;
	}
#endif
	strcpy(save_bones_compat_buf,
		"save and bones files accepted from version");
#ifdef VERSION_COMPATIBILITY
	sprintf(eos(save_bones_compat_buf),
		"s %lu.%lu.%lu%s through %d.%d.%d%s",
		((uver & 0xFF000000L) >> 24), ((uver & 0x00FF0000L) >> 16),
		((uver & 0x0000FF00L) >> 8), ueditsuffix,
		VERSION_MAJOR, VERSION_MINOR, PATCHLEVEL, editsuffix);
#else
	sprintf(eos(save_bones_compat_buf), " %d.%d.%d%s only",
		VERSION_MAJOR, VERSION_MINOR, PATCHLEVEL, editsuffix);
#endif
}

static const char *build_opts[] = {
#ifdef AMIGA_WBENCH
		"Amiga WorkBench support",
#endif
#ifdef ANSI_DEFAULT
		"ANSI default terminal",
#endif
/*WAC added for borg,  invisible objects, keep_save,noartifactwish */
#ifdef BORG
		"borg",               
#endif
#ifdef AUTOPICKUP_EXCEPTIONS
		"autopickup_exceptions",
#endif
#ifdef AUTO_OPEN
		"auto open doors",
#endif
#ifdef TEXTCOLOR
		"color",
#endif
#ifdef COM_COMPL
		"command line completion",
#endif
#ifdef COMPRESS
		"data file compression",
#endif
#ifdef DLB
		"data librarian",
#endif
#ifdef WIZARD
		"debug mode",
#endif
#ifdef REALTIME_ON_BOTL
                "elapsed time on status line",
#endif
		"Elbereth",
#ifdef MFLOPPY
		"floppy drive support",
#endif
#ifdef GOLDOBJ
		"gold object in inventories",
#endif
#ifdef INSURANCE
		"insurance files for recovering from crashes",
#endif
/*WAC invisible objects, keep_save,  light sourced spells*/
#ifdef LIGHT_SRC_SPELL
                "light sourced spell effects",               
#endif
                "invisible objects",               
#ifdef KEEP_SAVE
                "keep savefiles",
#endif
#ifdef HOLD_LOCKFILE_OPEN
		"exclusive lock on level 0 file",
#endif
#if defined(HANGUPHANDLING) && !defined(NO_SIGNAL)
#ifdef SAFERHANGUP
		"deferred handling of hangup signal",
#else
		"immediate handling of hangup signal",
#endif
#endif
#ifdef LOGFILE
		"log file",
#endif
#ifdef XLOGFILE
                "extended log file",
#endif
#ifdef MAIL
		"mail daemon",
#endif
#ifdef GNUDOS
		"MSDOS protected mode",
#endif
#ifdef NEWS
		"news file",
#endif
/* WAC added noartifactwish version info*/
#ifdef NOARTIFACTWISH
		"no wishing for special artifacts",
#endif
#ifdef OVERLAY
# ifdef MOVERLAY
		"MOVE overlays",
# else
#  ifdef VROOMM
		"VROOMM overlays",
#  else
		"overlays",
#  endif
# endif
#endif
#ifdef REINCARNATION
		"rogue level",
#endif
		"saddles and riding",
#ifdef DISPLAY_LAYERS
		"display layers",
#endif
#ifdef CLIPPING
		"screen clipping",
#endif
#ifdef NO_TERMS
# ifdef MAC
		"screen control via mactty",
# endif
# ifdef SCREEN_BIOS
		"screen control via BIOS",
# endif
# ifdef SCREEN_DJGPPFAST
		"screen control via DJGPP fast",
# endif
# ifdef SCREEN_VGA
		"screen control via VGA graphics",
# endif
# ifdef ALLEG_FX
		"screen control via Allegro library",
# endif
# ifndef MSWIN_GRAPHICS
#  ifdef WIN32CON
		"screen control via WIN32 console I/O",
#  endif
# endif
#endif
		"seduction",
#ifdef SHELL
		"shell command",
#endif
#ifdef SHOW_DMG
		"show damage amounts",
#endif
#ifdef SHOW_WEIGHT
		"show weight of inventory",
#endif
		"sinks",
#ifdef SUSPEND
		"suspend command",
#endif
#ifdef TERMINFO
		"terminal info library",
#else
# if defined(TERMLIB) || ((!defined(MICRO) && !defined(WIN32)) && defined(TTY_GRAPHICS))
		"terminal capability library",
# endif
#endif
#ifdef TIMED_DELAY
		"timed wait for display effects",
#endif
		"lightsabers",
		"Jedi",
		"firearms",
		"tourists",
#ifdef USER_SOUNDS
# ifdef USER_SOUNDS_REGEX
		"user sounds via regular expressions",
# else
		"user sounds via pmatch",
# endif
#endif
#ifdef PREFIXES_IN_USE
		"variable playground",
#endif
#ifdef VISION_TABLES
		"vision tables",
#endif
#ifdef WALLIFIED_MAZE
		"walled mazes",
#endif
		"yeomen",
#ifdef ZEROCOMP
		"zero-compressed save files",
#endif
#ifdef RECORD_TURNS
                "record turns in xlogfile",
#endif
#ifdef RECORD_CONDUCT
                "record conduct in xlogfile",
#endif
#ifdef RECORD_ACHIEVE
                "record major achievements in xlogfile",
#endif
#ifdef RECORD_REALTIME
                "record real time in xlogfile",
#endif
#ifdef RECORD_START_END_TIME
                "record starting and ending time in xlogfile",
#endif
#ifdef RECORD_GENDER0
                "record initial gender in xlogfile",
#endif
#ifdef RECORD_ALIGN0
                "record initial alignment in xlogfile",
#endif
		save_bones_compat_buf,
		"basic NetHack features"
	};

static const char *window_opts[] = {
#ifdef TTY_GRAPHICS
		"traditional tty-based graphics",
#endif
#ifdef CURSES_GRAPHICS
        "curses",
#endif
#ifdef X11_GRAPHICS
		"X11",
#endif
#ifdef QT_GRAPHICS
		"Qt",
#endif
#ifdef GTK_GRAPHICS
#ifdef GTK_PROXY
		"proxified GTK",
#else
		"GTK",
#endif
#endif
#ifdef GNOME_GRAPHICS
		"Gnome",
#endif
#ifdef GL_GRAPHICS
		"GL",
#endif
#ifdef SDL_GRAPHICS
		"SDL",
#endif
#ifdef MAC
		"Mac",
#endif
#ifdef AMIGA_INTUITION
		"Amiga Intuition",
#endif
#ifdef GEM_GRAPHICS
		"Gem",
#endif
#ifdef MSWIN_GRAPHICS
		"mswin",
#endif
#ifdef BEOS_GRAPHICS
		"BeOS InterfaceKit",
#endif
#ifdef PROXY_GRAPHICS
		"Plug-in modules",
#endif
		0
	};

void
do_options()
{
	register int i, length;
	register const char *str, *indent = "    ";

	filename[0]='\0';
#ifdef FILE_PREFIX
	strcat(filename,file_prefix);
#endif
	sprintf(eos(filename), DATA_TEMPLATE, OPTIONS_FILE);
	if (!(ofp = fopen(filename, WRTMODE))) {
		perror(filename);
		exit(EXIT_FAILURE);
	}

	build_savebones_compat_string();
	fprintf(ofp,"\n    %s version %d.%d.%d",
		DEF_GAME_NAME, VERSION_MAJOR, VERSION_MINOR, PATCHLEVEL);
#ifdef EDITLEVEL
	fprintf(ofp, "E%d", EDITLEVEL);
#ifdef FIXLEVEL
	fprintf(ofp, "F%d", FIXLEVEL);
#endif
#endif
#if defined(ALPHA)
	fprintf(ofp,"%s", " [alpha]\n");
#elif defined(BETA)
	fprintf(ofp,"%s", " [beta]\n");
#else
	fprintf(ofp,"%s", "\n");
#endif

	fprintf(ofp,"%s","\nOptions compiled into this edition:\n");

	length = COLNO + 1;	/* force 1st item onto new line */
	for (i = 0; i < SIZE(build_opts); i++) {
	    str = build_opts[i];
	    if (length + strlen(str) > COLNO - 5)
		fprintf(ofp,"\n%s", indent),  length = strlen(indent);
	    else
		fprintf(ofp,"%s"," "),  length++;
	    fprintf(ofp,"%s", str),  length += strlen(str);
	    fprintf(ofp,"%s",(i < SIZE(build_opts) - 1) ? "," : "."),  length++;
	}

	fprintf(ofp,"%s","\n\nSupported windowing systems:\n");

	length = COLNO + 1;	/* force 1st item onto new line */
	for (i = 0; i < SIZE(window_opts) - 1; i++) {
	    str = window_opts[i];
	    if (length + strlen(str) > COLNO - 5)
		fprintf(ofp,"\n%s", indent),  length = strlen(indent);
	    else
		fprintf(ofp,"%s"," "),  length++;
	    fprintf(ofp,"%s", str),  length += strlen(str);
	    fprintf(ofp, ","),  length++;
	}
	fprintf(ofp, "\n%swith a default of %s.", indent, DEFAULT_WINDOW_SYS);
	fprintf(ofp,"%s","\n\n");

	fclose(ofp);
	return;
}

/* routine to decide whether to discard something from data.base */
static boolean
d_filter(line)
    char *line;
{
    if (*line == '#') return TRUE;	/* ignore comment lines */
    return FALSE;
}

   /*
    *
	New format (v3.1) of 'data' file which allows much faster lookups [pr]
"do not edit"		first record is a comment line
01234567		hexadecimal formatted offset to text area
name-a			first name of interest
123,4			offset to name's text, and number of lines for it
name-b			next name of interest
name-c			multiple names which share same description also
456,7			share a single offset,count line
.			sentinel to mark end of names
789,0			dummy record containing offset, count of EOF
text-a			4 lines of descriptive text for name-a
text-a			at file position 0x01234567L + 123L
text-a
text-a
text-b/text-c		7 lines of text for names-b and -c
text-b/text-c		at fseek(0x01234567L + 456L)
...
    *
    */

void
do_data()
{
	char    *infile, *tempfile;
	boolean ok;
	long	txt_offset;
	int	entry_cnt, line_cnt;

	infile = malloc(strlen(DATA_IN_TEMPLATE) - 2 + strlen(DATA_FILE) + 6);
	tempfile = malloc(strlen(DATA_TEMPLATE) - 2 + strlen("database.tmp") + 1);
	sprintf(tempfile, DATA_TEMPLATE, "database.tmp");
	filename[0]='\0';
#ifdef FILE_PREFIX
	strcat(filename,file_prefix);
#endif
	sprintf(eos(filename), DATA_TEMPLATE, DATA_FILE);
	sprintf(infile, DATA_IN_TEMPLATE, DATA_FILE);
	strcat(infile, ".base");
	if (!(ifp = fopen(infile, RDTMODE))) {		/* data.base */
		perror(infile);
		exit(EXIT_FAILURE);
	}
	if (!(ofp = fopen(filename, WRTMODE))) {	/* data */
		perror(filename);
		fclose(ifp);
		exit(EXIT_FAILURE);
	}
	free(infile);
	if (!(tfp = fopen(tempfile, WRTMODE))) {	/* database.tmp */
		perror(tempfile);
		fclose(ifp);
		fclose(ofp);
		unlink(filename);
		exit(EXIT_FAILURE);
	}

	/* output a dummy header record; we'll rewind and overwrite it later */
	fprintf(ofp, "%s%08lx\n", Dont_Edit_Data, 0L);

	entry_cnt = line_cnt = 0;
	/* read through the input file and split it into two sections */
	while (fgets(in_line, sizeof in_line, ifp)) {
	    if (d_filter(in_line)) continue;
	    if (*in_line > ' ') {	/* got an entry name */
		/* first finish previous entry */
		if (line_cnt)  fprintf(ofp, "%d\n", line_cnt),  line_cnt = 0;
		/* output the entry name */
		(void) fputs(in_line, ofp);
		entry_cnt++;		/* update number of entries */
	    } else if (entry_cnt) {	/* got some descriptive text */
		/* update previous entry with current text offset */
		if (!line_cnt)  fprintf(ofp, "%ld,", ftell(tfp));
		/* save the text line in the scratch file */
		(void) fputs(in_line, tfp);
		line_cnt++;		/* update line counter */
	    }
	}
	/* output an end marker and then record the current position */
	if (line_cnt)  fprintf(ofp, "%d\n", line_cnt);
	fprintf(ofp, ".\n%ld,%d\n", ftell(tfp), 0);
	txt_offset = ftell(ofp);
	fclose(ifp);		/* all done with original input file */

	/* reprocess the scratch file; 1st format an error msg, just in case */
	sprintf(in_line, "rewind of \"%s\"", tempfile);
	if (rewind(tfp) != 0)  goto dead_data;
	/* copy all lines of text from the scratch file into the output file */
	while (fgets(in_line, sizeof in_line, tfp))
	    (void) fputs(in_line, ofp);

	/* finished with scratch file */
	fclose(tfp);
	unlink(tempfile);	/* remove it */
	free(tempfile);

	/* update the first record of the output file; prepare error msg 1st */
	sprintf(in_line, "rewind of \"%s\"", filename);
	ok = (rewind(ofp) == 0);
	if (ok) {
	   sprintf(in_line, "header rewrite of \"%s\"", filename);
	   ok = (fprintf(ofp, "%s%08lx\n", Dont_Edit_Data, txt_offset) >= 0);
	}
	if (!ok) {
dead_data:  perror(in_line);	/* report the problem */
	    /* close and kill the aborted output file, then give up */
	    fclose(ofp);
	    unlink(filename);
	    exit(EXIT_FAILURE);
	}

	/* all done */
	fclose(ofp);

	return;
}

/* routine to decide whether to discard something from oracles.txt */
static boolean
h_filter(line)
    char *line;
{
    static boolean skip = FALSE;
    char tag[sizeof in_line];

    SpinCursor(3);

    if (*line == '#') return TRUE;	/* ignore comment lines */
    if (sscanf(line, "----- %s", tag) == 1) {
	skip = FALSE;
    } else if (skip && !strncmp(line, "-----", 5))
	skip = FALSE;
    return skip;
}

static const char *special_oracle[] = {
	"\"...it is rather disconcerting to be confronted with the",
	"following theorem from [Baker, Gill, and Solovay, 1975].",
	"",
	"Theorem 7.18  There exist recursive languages A and B such that",
	"  (1)  P(A) == NP(A), and",
	"  (2)  P(B) != NP(B)",
	"",
	"This provides impressive evidence that the techniques that are",
	"currently available will not suffice for proving that P != NP or          ",
	"that P == NP.\"  [Garey and Johnson, p. 185.]"
};

/*
   The oracle file consists of a "do not edit" comment, a decimal count N
   and set of N+1 hexadecimal fseek offsets, followed by N multiple-line
   records, separated by "---" lines.  The first oracle is a special case.
   The input data contains just those multi-line records, separated by
   "-----" lines.
 */

void
do_oracles()
{
	char    *infile, *tempfile;
	boolean in_oracle, ok;
	long	txt_offset, offset, fpos;
	int	oracle_cnt;
	register int i;

	infile = malloc(strlen(DATA_IN_TEMPLATE) - 2 + strlen(ORACLE_FILE) + 5);
	tempfile = malloc(strlen(DATA_TEMPLATE) - 2 + strlen("oracles.tmp") + 1);
	sprintf(tempfile, DATA_TEMPLATE, "oracles.tmp");
	filename[0]='\0';
#ifdef FILE_PREFIX
	strcat(filename, file_prefix);
#endif
	sprintf(eos(filename), DATA_TEMPLATE, ORACLE_FILE);
	sprintf(infile, DATA_IN_TEMPLATE, ORACLE_FILE);
	strcat(infile, ".txt");
	if (!(ifp = fopen(infile, RDTMODE))) {
		perror(infile);
		exit(EXIT_FAILURE);
	}
	free(infile);
	if (!(ofp = fopen(filename, WRTMODE))) {
		perror(filename);
		fclose(ifp);
		exit(EXIT_FAILURE);
	}
	if (!(tfp = fopen(tempfile, WRTMODE))) {	/* oracles.tmp */
		perror(tempfile);
		fclose(ifp);
		fclose(ofp);
		unlink(filename);
		exit(EXIT_FAILURE);
	}

	/* output a dummy header record; we'll rewind and overwrite it later */
	fprintf(ofp, "%s%5d\n", Dont_Edit_Data, 0);

	/* handle special oracle; it must come first */
	(void) fputs("---\n", tfp);
	fprintf(ofp, "%05lx\n", ftell(tfp));  /* start pos of special oracle */
	for (i = 0; i < SIZE(special_oracle); i++) {
	    (void) fputs(xcrypt(special_oracle[i]), tfp);
	    (void) fputc('\n', tfp);
	}
	SpinCursor(3);

	oracle_cnt = 1;
	(void) fputs("---\n", tfp);
	fprintf(ofp, "%05lx\n", ftell(tfp));	/* start pos of first oracle */
	in_oracle = FALSE;

	while (fgets(in_line, sizeof in_line, ifp)) {
	    SpinCursor(3);

	    if (h_filter(in_line)) continue;
	    if (!strncmp(in_line, "-----", 5)) {
		if (!in_oracle) continue;
		in_oracle = FALSE;
		oracle_cnt++;
		(void) fputs("---\n", tfp);
		fprintf(ofp, "%05lx\n", ftell(tfp));
		/* start pos of this oracle */
	    } else {
		in_oracle = TRUE;
		(void) fputs(xcrypt(in_line), tfp);
	    }
	}

	if (in_oracle) {	/* need to terminate last oracle */
	    oracle_cnt++;
	    (void) fputs("---\n", tfp);
	    fprintf(ofp, "%05lx\n", ftell(tfp));	/* eof position */
	}

	/* record the current position */
	txt_offset = ftell(ofp);
	fclose(ifp);		/* all done with original input file */

	/* reprocess the scratch file; 1st format an error msg, just in case */
	sprintf(in_line, "rewind of \"%s\"", tempfile);
	if (rewind(tfp) != 0)  goto dead_data;
	/* copy all lines of text from the scratch file into the output file */
	while (fgets(in_line, sizeof in_line, tfp))
	    (void) fputs(in_line, ofp);

	/* finished with scratch file */
	fclose(tfp);
	unlink(tempfile);	/* remove it */
	free(tempfile);

	/* update the first record of the output file; prepare error msg 1st */
	sprintf(in_line, "rewind of \"%s\"", filename);
	ok = (rewind(ofp) == 0);
	if (ok) {
	    sprintf(in_line, "header rewrite of \"%s\"", filename);
	    ok = (fprintf(ofp, "%s%5d\n", Dont_Edit_Data, oracle_cnt) >=0);
	}
	if (ok) {
	    sprintf(in_line, "data rewrite of \"%s\"", filename);
	    for (i = 0; i <= oracle_cnt; i++) {
#ifndef VMS	/* alpha/vms v1.0; this fflush seems to confuse ftell */
		if (!(ok = (fflush(ofp) == 0))) break;
#endif
		if (!(ok = (fpos = ftell(ofp)) >= 0)) break;
		if (!(ok = (fseek(ofp, fpos, SEEK_SET) >= 0))) break;
		if (!(ok = (fscanf(ofp, "%5lx", &offset) == 1))) break;
#ifdef MAC
# ifdef __MWERKS__
		/*
		MetroWerks CodeWarrior Pro 1's (AKA CW12) version of MSL
		(ANSI C Libraries) needs this rewind or else the fprintf
		stops working.  This may also be true for CW11, but has
		never been checked.
		*/
		rewind(ofp);
# endif
#endif
		if (!(ok = (fseek(ofp, fpos, SEEK_SET) >= 0))) break;
		if (!(ok = (fprintf(ofp, "%05lx\n", offset + txt_offset) >= 0)))
		    break;
	    }
	}
	if (!ok) {
dead_data:  perror(in_line);	/* report the problem */
	    /* close and kill the aborted output file, then give up */
	    /* KMH -- I don't know why it fails */
#ifndef MAC
	    fclose(ofp);
	    unlink(filename);
	    exit(EXIT_FAILURE);
#endif
	}

	/* all done */
	fclose(ofp);

	return;
}


static	struct deflist {

	const char	*defname;
	boolean	true_or_false;
} deflist[] = {
#ifdef REINCARNATION
	      {	"REINCARNATION", TRUE },
#else
	      {	"REINCARNATION", FALSE },
#endif
	      { 0, 0 } };

static int
check_control(s)
	char	*s;
{
	int	i;

	if(s[0] != '%') return(-1);

	for(i = 0; deflist[i].defname; i++)
	    if(!strncmp(deflist[i].defname, s+1, strlen(deflist[i].defname)))
		return(i);

	return(-1);
}

static char *
without_control(s)
	char *s;
{
	return(s + 1 + strlen(deflist[check_control(in_line)].defname));
}

void
do_dungeon()
{
	int rcnt = 0;

	sprintf(filename, DATA_IN_TEMPLATE, DGN_I_FILE);
	if (!(ifp = fopen(filename, RDTMODE))) {
		perror(filename);
		exit(EXIT_FAILURE);
	}
	filename[0]='\0';
#ifdef FILE_PREFIX
	strcat(filename, file_prefix);
#endif
	sprintf(eos(filename), DGN_TEMPLATE, DGN_O_FILE);
	if (!(ofp = fopen(filename, WRTMODE))) {
		perror(filename);
		exit(EXIT_FAILURE);
	}
	fprintf(ofp,"%s",Dont_Edit_Data);

	while (fgets(in_line, sizeof in_line, ifp) != 0) {
	    SpinCursor(3);

	    rcnt++;
	    if(in_line[0] == '#') continue;	/* discard comments */
recheck:
	    if(in_line[0] == '%') {
		int i = check_control(in_line);
		if(i >= 0) {
		    if(!deflist[i].true_or_false)  {
			while (fgets(in_line, sizeof in_line, ifp) != 0)
			    if(check_control(in_line) != i) goto recheck;
		    } else
			(void) fputs(without_control(in_line),ofp);
		} else {
		    fprintf(stderr, "Unknown control option '%s' in file %s at line %d.\n",
			    in_line, DGN_I_FILE, rcnt);
		    exit(EXIT_FAILURE);
		}
	    } else
		(void) fputs(in_line,ofp);
	}
	fclose(ifp);
	fclose(ofp);

	sprintf(filename, DATA_IN_TEMPLATE, DGN_I_FILE2);
	if (!(ifp = fopen(filename, RDTMODE))) {
		perror(filename);
		exit(EXIT_FAILURE);
	}
	filename[0]='\0';
#ifdef FILE_PREFIX
	strcat(filename, file_prefix);
#endif
	sprintf(eos(filename), DGN_TEMPLATE, DGN_O_FILE2);
	if (!(ofp = fopen(filename, WRTMODE))) {
		perror(filename);
		exit(EXIT_FAILURE);
	}
	fprintf(ofp,"%s",Dont_Edit_Data);

	while (fgets(in_line, sizeof in_line, ifp) != 0) {
	    SpinCursor(3);

	    rcnt++;
	    if(in_line[0] == '#') continue;	/* discard comments */
recheck2:
	    if(in_line[0] == '%') {
		int i = check_control(in_line);
		if(i >= 0) {
		    if(!deflist[i].true_or_false)  {
			while (fgets(in_line, sizeof in_line, ifp) != 0)
			    if(check_control(in_line) != i) goto recheck2;
		    } else
			(void) fputs(without_control(in_line),ofp);
		} else {
		    fprintf(stderr, "Unknown control option '%s' in file %s at line %d.\n",
			    in_line, DGN_I_FILE2, rcnt);
		    exit(EXIT_FAILURE);
		}
	    } else
		(void) fputs(in_line,ofp);
	}
	fclose(ifp);
	fclose(ofp);

	sprintf(filename, DATA_IN_TEMPLATE, DGN_I_FILE3);
	if (!(ifp = fopen(filename, RDTMODE))) {
		perror(filename);
		exit(EXIT_FAILURE);
	}
	filename[0]='\0';
#ifdef FILE_PREFIX
	strcat(filename, file_prefix);
#endif
	sprintf(eos(filename), DGN_TEMPLATE, DGN_O_FILE3);
	if (!(ofp = fopen(filename, WRTMODE))) {
		perror(filename);
		exit(EXIT_FAILURE);
	}
	fprintf(ofp,"%s",Dont_Edit_Data);

	while (fgets(in_line, sizeof in_line, ifp) != 0) {
	    SpinCursor(3);

	    rcnt++;
	    if(in_line[0] == '#') continue;	/* discard comments */
recheck3:
	    if(in_line[0] == '%') {
		int i = check_control(in_line);
		if(i >= 0) {
		    if(!deflist[i].true_or_false)  {
			while (fgets(in_line, sizeof in_line, ifp) != 0)
			    if(check_control(in_line) != i) goto recheck3;
		    } else
			(void) fputs(without_control(in_line),ofp);
		} else {
		    fprintf(stderr, "Unknown control option '%s' in file %s at line %d.\n",
			    in_line, DGN_I_FILE3, rcnt);
		    exit(EXIT_FAILURE);
		}
	    } else
		(void) fputs(in_line,ofp);
	}
	fclose(ifp);
	fclose(ofp);

	sprintf(filename, DATA_IN_TEMPLATE, DGN_I_FILE4);
	if (!(ifp = fopen(filename, RDTMODE))) {
		perror(filename);
		exit(EXIT_FAILURE);
	}
	filename[0]='\0';
#ifdef FILE_PREFIX
	strcat(filename, file_prefix);
#endif
	sprintf(eos(filename), DGN_TEMPLATE, DGN_O_FILE4);
	if (!(ofp = fopen(filename, WRTMODE))) {
		perror(filename);
		exit(EXIT_FAILURE);
	}
	fprintf(ofp,"%s",Dont_Edit_Data);

	while (fgets(in_line, sizeof in_line, ifp) != 0) {
	    SpinCursor(3);

	    rcnt++;
	    if(in_line[0] == '#') continue;	/* discard comments */
recheck4:
	    if(in_line[0] == '%') {
		int i = check_control(in_line);
		if(i >= 0) {
		    if(!deflist[i].true_or_false)  {
			while (fgets(in_line, sizeof in_line, ifp) != 0)
			    if(check_control(in_line) != i) goto recheck4;
		    } else
			(void) fputs(without_control(in_line),ofp);
		} else {
		    fprintf(stderr, "Unknown control option '%s' in file %s at line %d.\n",
			    in_line, DGN_I_FILE4, rcnt);
		    exit(EXIT_FAILURE);
		}
	    } else
		(void) fputs(in_line,ofp);
	}
	fclose(ifp);
	fclose(ofp);

	sprintf(filename, DATA_IN_TEMPLATE, DGN_I_FILE5);
	if (!(ifp = fopen(filename, RDTMODE))) {
		perror(filename);
		exit(EXIT_FAILURE);
	}
	filename[0]='\0';
#ifdef FILE_PREFIX
	strcat(filename, file_prefix);
#endif
	sprintf(eos(filename), DGN_TEMPLATE, DGN_O_FILE5);
	if (!(ofp = fopen(filename, WRTMODE))) {
		perror(filename);
		exit(EXIT_FAILURE);
	}
	fprintf(ofp,"%s",Dont_Edit_Data);

	while (fgets(in_line, sizeof in_line, ifp) != 0) {
	    SpinCursor(3);

	    rcnt++;
	    if(in_line[0] == '#') continue;	/* discard comments */
recheck5:
	    if(in_line[0] == '%') {
		int i = check_control(in_line);
		if(i >= 0) {
		    if(!deflist[i].true_or_false)  {
			while (fgets(in_line, sizeof in_line, ifp) != 0)
			    if(check_control(in_line) != i) goto recheck5;
		    } else
			(void) fputs(without_control(in_line),ofp);
		} else {
		    fprintf(stderr, "Unknown control option '%s' in file %s at line %d.\n",
			    in_line, DGN_I_FILE5, rcnt);
		    exit(EXIT_FAILURE);
		}
	    } else
		(void) fputs(in_line,ofp);
	}
	fclose(ifp);
	fclose(ofp);

	sprintf(filename, DATA_IN_TEMPLATE, DGN_I_FILE6);
	if (!(ifp = fopen(filename, RDTMODE))) {
		perror(filename);
		exit(EXIT_FAILURE);
	}
	filename[0]='\0';
#ifdef FILE_PREFIX
	strcat(filename, file_prefix);
#endif
	sprintf(eos(filename), DGN_TEMPLATE, DGN_O_FILE6);
	if (!(ofp = fopen(filename, WRTMODE))) {
		perror(filename);
		exit(EXIT_FAILURE);
	}
	fprintf(ofp,"%s",Dont_Edit_Data);

	while (fgets(in_line, sizeof in_line, ifp) != 0) {
	    SpinCursor(3);

	    rcnt++;
	    if(in_line[0] == '#') continue;	/* discard comments */
recheck6:
	    if(in_line[0] == '%') {
		int i = check_control(in_line);
		if(i >= 0) {
		    if(!deflist[i].true_or_false)  {
			while (fgets(in_line, sizeof in_line, ifp) != 0)
			    if(check_control(in_line) != i) goto recheck6;
		    } else
			(void) fputs(without_control(in_line),ofp);
		} else {
		    fprintf(stderr, "Unknown control option '%s' in file %s at line %d.\n",
			    in_line, DGN_I_FILE6, rcnt);
		    exit(EXIT_FAILURE);
		}
	    } else
		(void) fputs(in_line,ofp);
	}
	fclose(ifp);
	fclose(ofp);

	sprintf(filename, DATA_IN_TEMPLATE, DGN_I_FILE7);
	if (!(ifp = fopen(filename, RDTMODE))) {
		perror(filename);
		exit(EXIT_FAILURE);
	}
	filename[0]='\0';
#ifdef FILE_PREFIX
	strcat(filename, file_prefix);
#endif
	sprintf(eos(filename), DGN_TEMPLATE, DGN_O_FILE7);
	if (!(ofp = fopen(filename, WRTMODE))) {
		perror(filename);
		exit(EXIT_FAILURE);
	}
	fprintf(ofp,"%s",Dont_Edit_Data);

	while (fgets(in_line, sizeof in_line, ifp) != 0) {
	    SpinCursor(3);

	    rcnt++;
	    if(in_line[0] == '#') continue;	/* discard comments */
recheck7:
	    if(in_line[0] == '%') {
		int i = check_control(in_line);
		if(i >= 0) {
		    if(!deflist[i].true_or_false)  {
			while (fgets(in_line, sizeof in_line, ifp) != 0)
			    if(check_control(in_line) != i) goto recheck7;
		    } else
			(void) fputs(without_control(in_line),ofp);
		} else {
		    fprintf(stderr, "Unknown control option '%s' in file %s at line %d.\n",
			    in_line, DGN_I_FILE7, rcnt);
		    exit(EXIT_FAILURE);
		}
	    } else
		(void) fputs(in_line,ofp);
	}
	fclose(ifp);
	fclose(ofp);

	sprintf(filename, DATA_IN_TEMPLATE, DGN_I_FILE8);
	if (!(ifp = fopen(filename, RDTMODE))) {
		perror(filename);
		exit(EXIT_FAILURE);
	}
	filename[0]='\0';
#ifdef FILE_PREFIX
	strcat(filename, file_prefix);
#endif
	sprintf(eos(filename), DGN_TEMPLATE, DGN_O_FILE8);
	if (!(ofp = fopen(filename, WRTMODE))) {
		perror(filename);
		exit(EXIT_FAILURE);
	}
	fprintf(ofp,"%s",Dont_Edit_Data);

	while (fgets(in_line, sizeof in_line, ifp) != 0) {
	    SpinCursor(3);

	    rcnt++;
	    if(in_line[0] == '#') continue;	/* discard comments */
recheck8:
	    if(in_line[0] == '%') {
		int i = check_control(in_line);
		if(i >= 0) {
		    if(!deflist[i].true_or_false)  {
			while (fgets(in_line, sizeof in_line, ifp) != 0)
			    if(check_control(in_line) != i) goto recheck8;
		    } else
			(void) fputs(without_control(in_line),ofp);
		} else {
		    fprintf(stderr, "Unknown control option '%s' in file %s at line %d.\n",
			    in_line, DGN_I_FILE8, rcnt);
		    exit(EXIT_FAILURE);
		}
	    } else
		(void) fputs(in_line,ofp);
	}
	fclose(ifp);
	fclose(ofp);

	return;
}

static boolean
ranged_attk(ptr)	/* returns TRUE if monster can attack at range */
	register struct permonst *ptr;
{
	register int	i, j;
	register int atk_mask = (1<<AT_BREA) | (1<<AT_SPIT) | (1<<AT_GAZE);

	for(i = 0; i < NATTK; i++) {
	    if((j=ptr->mattk[i].aatyp) >= AT_WEAP || (atk_mask & (1<<j)))
		return TRUE;
	}

	return(FALSE);
}

/* This routine is designed to return an integer value which represents
 * an approximation of monster strength.  It uses a similar method of
 * determination as "experience()" to arrive at the strength.
 */
static int
mstrength(ptr)
struct permonst *ptr;
{
	int	i, tmp2, n, tmp = ptr->mlevel;

	/*if(tmp > 49)*/		/* special fixed hp monster */
	    /*tmp = 2*(tmp - 6) / 4;*/ 	/* what the heck does that have to do with monster difficulty?! --Amy */

/*	For creation in groups */
	n = (!!(ptr->geno & G_SGROUP));
	n += (!!(ptr->geno & G_LGROUP)) << 1;
	n += (!!(ptr->geno & G_VLGROUP)) << 2;

/*	For ranged attacks */
	if (ranged_attk(ptr)) n++;

/*	For higher ac values */
	n += (ptr->ac < 4);
	n += (ptr->ac < 0);

/*	For very fast monsters */
	n += (ptr->mmove >= 18);

/*	Amy edit - that didn't make any difference, so let's make monster speed actually matter. */
	n += (ptr->mmove >= 16);
	n += (ptr->mmove >= 18);
	n += (ptr->mmove >= 20);
	n += (ptr->mmove >= 22);
	n += (ptr->mmove >= 24);
	n += (ptr->mmove >= 27);
	n += (ptr->mmove >= 30);
	n += (ptr->mmove >= 33);
	n += (ptr->mmove >= 36);
	n += (ptr->mmove >= 39);
	n += (ptr->mmove >= 42);
	n += (ptr->mmove >= 45);
	n += (ptr->mmove >= 48);
	n += (ptr->mmove >= 51);
	n += (ptr->mmove >= 54);
	n += (ptr->mmove >= 57);
	n += (ptr->mmove >= 60);

/*	For each attack and "special" attack */
	for(i = 0; i < NATTK; i++) {

	    tmp2 = ptr->mattk[i].aatyp;
	    n += (tmp2 > 0);
	    n += (tmp2 == AT_MAGC);
	    n += (tmp2 == AT_WEAP && (ptr->mflags2 & M2_STRONG));
	}

/*	For each "special" damage type */
	for(i = 0; i < NATTK; i++) {

	    tmp2 = ptr->mattk[i].adtyp;
	    if ((tmp2 == AD_DRLI) || (tmp2 == AD_STON) || (tmp2 == AD_DRST)
		|| (tmp2 == AD_DRDX) || (tmp2 == AD_DRCO) || (tmp2 == AD_WERE))
			n += 2;
	    n += (tmp2 != AD_PHYS); /* don't special-case grid bugs --Amy */
	    n += ((int) (ptr->mattk[i].damd * ptr->mattk[i].damn) > 23);
	}
	/* tom's nasties */
	if (extra_nasty(ptr)) n += 5;

/*	Leprechauns are special cases.  They have many hit dice so they
	can hit and are hard to kill, but they don't really do much damage.
	Amy edit: I don't care, we don't need special cases :P */
/*	if (!strcmp(ptr->mname, "leprechaun")) n -= 2;*/

/*	Finally, adjust the monster level  0 <= n <= 24 (approx.) */
	if(n == 0) tmp--;
	else if(n >= 6) tmp += ( n / 2 );
	else tmp += ( n / 3 + 1);

	if (tmp > 75) tmp = 75;

	return((tmp >= 0) ? tmp : 0);
}

void
do_monstr()
{
    register struct permonst *ptr;
    register int i, j;

    /*
     * create the source file, "monstr.c"
     */
    filename[0]='\0';
#ifdef FILE_PREFIX
    strcat(filename, file_prefix);
#endif
    sprintf(eos(filename), SOURCE_TEMPLATE, MON_STR_C);
    if (!(ofp = fopen(filename, WRTMODE))) {
	perror(filename);
	exit(EXIT_FAILURE);
    }
    fprintf(ofp,"%s",Dont_Edit_Code);
    fprintf(ofp,"%s","#include \"config.h\"\n");
    fprintf(ofp,"%s","\nconst int monstr[] = {\n");
    for (ptr = &mons[0], j = 0; ptr->mlet; ptr++) {

	SpinCursor(3);

	i = mstrength(ptr);
	fprintf(ofp,"%2d,%c", i, (++j & 15) ? ' ' : '\n');
    }
    /* might want to insert a final 0 entry here instead of just newline */
    fprintf(ofp,"%s};\n", (j & 15) ? "\n" : "");

    fprintf(ofp,"%s","\nvoid monstr_init(void);\n");
    fprintf(ofp,"%s","\nvoid\n");
    fprintf(ofp,"%s","monstr_init()\n");
    fprintf(ofp,"%s","{\n");
    fprintf(ofp,"%s","    return;\n");
    fprintf(ofp,"%s","}\n");
    fprintf(ofp,"%s","\n/*monstr.c*/\n");

    fclose(ofp);
    return;
}

void
do_permonst()
{
	int	i;
	char	*c, *nam;

	filename[0]='\0';
#ifdef FILE_PREFIX
	strcat(filename, file_prefix);
#endif
	sprintf(eos(filename), INCLUDE_TEMPLATE, MONST_FILE);
	if (!(ofp = fopen(filename, WRTMODE))) {
		perror(filename);
		exit(EXIT_FAILURE);
	}
	fprintf(ofp,"%s","/*\tSCCS Id: @(#)pm.h\t3.4\t2002/02/03 */\n\n");
	fprintf(ofp,"%s",Dont_Edit_Code);
	fprintf(ofp,"%s","#ifndef PM_H\n#define PM_H\n");

	if (strcmp(mons[0].mname, "playermon") != 0)
		fprintf(ofp,"%s","\n#define\tPM_PLAYERMON\t(-1)");

	for (i = 0; mons[i].mlet; i++) {
		SpinCursor(3);
		fprintf(ofp,"%s","\n#define\tPM_");
		if (mons[i].mflags4 & M4_HUMANWERE)
		    fprintf(ofp,"%s", "HUMAN_");
		for (nam = c = tmpdup(mons[i].mname); *c; c++)
		    if (*c >= 'a' && *c <= 'z') *c -= (char)('a' - 'A');
		    else if (*c < 'A' || *c > 'Z') *c = '_';
		fprintf(ofp,"%s\t%d", nam, i);
	}
	fprintf(ofp,"\n\n#define\tNUMMONS\t%d\n", i);
	fprintf(ofp,"%s","\n#endif /* PM_H */\n");
	fclose(ofp);
	return;
}


/*	Start of Quest text file processing. */
#include "qtext.h"

static struct qthdr	qt_hdr;
static struct msghdr	msg_hdr[N_HDR];
static struct qtmsg	*curr_msg;

static int	qt_line;

static boolean	in_msg;
#define NO_MSG	1	/* strlen of a null line returned by fgets() */

static boolean
qt_comment(s)
	char *s;
{
	if(s[0] == '#') return(TRUE);
	return((boolean)(!in_msg  && strlen(s) == NO_MSG));
}

static boolean
qt_control(s)
	char *s;
{
	return((boolean)(s[0] == '%' && (s[1] == 'C' || s[1] == 'E')));
}

static int
get_hdr (code)
	char *code;
{
	int	i;

	for(i = 0; i < qt_hdr.n_hdr; i++)
	    if(!strncmp(code, qt_hdr.id[i], LEN_HDR)) return (++i);

	return(0);
}

static boolean
new_id (code)
	char *code;
{
	if(qt_hdr.n_hdr >= N_HDR) {
	    fprintf(stderr, OUT_OF_HEADERS, qt_line);
	    return(FALSE);
	}

	strncpy(&qt_hdr.id[qt_hdr.n_hdr][0], code, LEN_HDR);
	msg_hdr[qt_hdr.n_hdr].n_msg = 0;
	qt_hdr.offset[qt_hdr.n_hdr++] = 0L;
	return(TRUE);
}

static boolean
known_msg(num, id)
	int num, id;
{
	int i;

	for(i = 0; i < msg_hdr[num].n_msg; i++)
	    if(msg_hdr[num].qt_msg[i].msgnum == id) return(TRUE);

	return(FALSE);
}


static void
new_msg(s, num, id)
	char *s;
	int num, id;
{
	struct	qtmsg	*qt_msg;

	if(msg_hdr[num].n_msg >= N_MSG) {
		fprintf(stderr, OUT_OF_MESSAGES, qt_line);
	} else {
		qt_msg = &(msg_hdr[num].qt_msg[msg_hdr[num].n_msg++]);
		qt_msg->msgnum = id;
		qt_msg->delivery = s[2];
		qt_msg->offset = qt_msg->size = 0L;

		curr_msg = qt_msg;
	}
}

static void
do_qt_control(s)
	char *s;
{
	char code[BUFSZ];
	int num, id = 0;

	switch(s[1]) {

	    case 'C':	if(in_msg) {
			    fprintf(stderr, CREC_IN_MSG, qt_line);
			    break;
			} else {
			    in_msg = TRUE;
			    if (sscanf(&s[4], "%s %5d", code, &id) != 2) {
			    	fprintf(stderr, UNREC_CREC, qt_line);
			    	break;
			    }
			    num = get_hdr(code);
			    if (!num && !new_id(code))
			    	break;
			    num = get_hdr(code)-1;
			    if(known_msg(num, id))
			    	fprintf(stderr, DUP_MSG, qt_line);
			    else new_msg(s, num, id);
			}
			break;

	    case 'E':	if(!in_msg) {
			    fprintf(stderr, END_NOT_IN_MSG, qt_line);
			    break;
			} else in_msg = FALSE;
			break;

	    default:	fprintf(stderr, UNREC_CREC, qt_line);
			break;
	}
}

static void
do_qt_text(s)
	char *s;
{
	if (!in_msg) {
	    fprintf(stderr, TEXT_NOT_IN_MSG, qt_line);
	}
	curr_msg->size += strlen(s);
	return;
}

static void
adjust_qt_hdrs()
{
	int	i, j;
	long count = 0L, hdr_offset = sizeof(int) +
			(sizeof(char)*LEN_HDR + sizeof(long)) * qt_hdr.n_hdr;

	for(i = 0; i < qt_hdr.n_hdr; i++) {
	    qt_hdr.offset[i] = hdr_offset;
	    hdr_offset += sizeof(int) + sizeof(struct qtmsg) * msg_hdr[i].n_msg;
	}

	for(i = 0; i < qt_hdr.n_hdr; i++)
	    for(j = 0; j < msg_hdr[i].n_msg; j++) {
		msg_hdr[i].qt_msg[j].offset = hdr_offset + count;
		count += msg_hdr[i].qt_msg[j].size;
	    }
	return;
}

static void
put_qt_hdrs()
{
	int	i;

	/*
	 *	The main header record.
	 */
#ifdef DEBUG
	fprintf(stderr, "%ld: header info.\n", ftell(ofp));
#endif
	(void) fwrite((void *)&(qt_hdr.n_hdr), sizeof(int), 1, ofp);
	(void) fwrite((void *)&(qt_hdr.id[0][0]), sizeof(char)*LEN_HDR,
							qt_hdr.n_hdr, ofp);
	(void) fwrite((void *)&(qt_hdr.offset[0]), sizeof(long),
							qt_hdr.n_hdr, ofp);
#ifdef DEBUG
	for(i = 0; i < qt_hdr.n_hdr; i++)
		fprintf(stderr, "%c @ %ld, ", qt_hdr.id[i], qt_hdr.offset[i]);

	fprintf(stderr,"%s", "\n");
#endif

	/*
	 *	The individual class headers.
	 */
	for(i = 0; i < qt_hdr.n_hdr; i++) {

#ifdef DEBUG
	    fprintf(stderr, "%ld: %c header info.\n", ftell(ofp),
		    qt_hdr.id[i]);
#endif
	    (void) fwrite((void *)&(msg_hdr[i].n_msg), sizeof(int),
							1, ofp);
	    (void) fwrite((void *)&(msg_hdr[i].qt_msg[0]),
			    sizeof(struct qtmsg), msg_hdr[i].n_msg, ofp);
#ifdef DEBUG
	    { int j;
	      for(j = 0; j < msg_hdr[i].n_msg; j++)
		fprintf(stderr, "msg %d @ %ld (%ld)\n",
			msg_hdr[i].qt_msg[j].msgnum,
			msg_hdr[i].qt_msg[j].offset,
			msg_hdr[i].qt_msg[j].size);
	    }
#endif
	}
}

void
do_questtxt()
{
	sprintf(filename, DATA_IN_TEMPLATE, QTXT_I_FILE);
	ifp = fopen(filename, RDTMODE);
	if(!ifp) {
		perror(filename);
		exit(EXIT_FAILURE);
	}

	filename[0]='\0';
#ifdef FILE_PREFIX
	strcat(filename, file_prefix);
#endif
	sprintf(eos(filename), DATA_TEMPLATE, QTXT_O_FILE);
	if(!(ofp = fopen(filename, WRBMODE))) {
		perror(filename);
		fclose(ifp);
		exit(EXIT_FAILURE);
	}

	qt_hdr.n_hdr = 0;
	qt_line = 0;
	in_msg = FALSE;

	while (fgets(in_line, 80, ifp) != 0) {
	    SpinCursor (3);

	    qt_line++;
	    if(qt_control(in_line)) do_qt_control(in_line);
	    else if(qt_comment(in_line)) continue;
	    else		    do_qt_text(in_line);
	}

	(void) rewind(ifp);
	in_msg = FALSE;
	adjust_qt_hdrs();
	put_qt_hdrs();
	while (fgets(in_line, 80, ifp) != 0) {

		if(qt_control(in_line)) {
		    in_msg = (in_line[1] == 'C');
		    continue;
		} else if(qt_comment(in_line)) continue;
#ifdef DEBUG
		fprintf(stderr, "%ld: %s", ftell(stdout), in_line);
#endif
		(void) fputs(xcrypt(in_line), ofp);
	}
	fclose(ifp);
	fclose(ofp);
	return;
}


static	char	temp[32];

static char *
limit(name,pref)	/* limit a name to 30 characters length */
char	*name;
int	pref;
{
	(void) strncpy(temp, name, pref ? 26 : 30);
	temp[pref ? 26 : 30] = 0;
	return temp;
}

void
do_objs()
{
	int i, sum = 0;
	char *c, *objnam;
	int nspell = 0;
	int prefix = 0;
	char class = '\0';
	boolean	sumerr = FALSE;

	filename[0]='\0';
#ifdef FILE_PREFIX
	strcat(filename, file_prefix);
#endif
	sprintf(eos(filename), INCLUDE_TEMPLATE, ONAME_FILE);
	if (!(ofp = fopen(filename, WRTMODE))) {
		perror(filename);
		exit(EXIT_FAILURE);
	}
	fprintf(ofp,"%s","/*\tSCCS Id: @(#)onames.h\t3.4\t2002/02/03 */\n\n");
	fprintf(ofp,"%s",Dont_Edit_Code);
	fprintf(ofp,"%s","#ifndef ONAMES_H\n#define ONAMES_H\n\n");

	for(i = 0; !i || objects[i].oc_class != ILLOBJ_CLASS; i++) {
		SpinCursor(3);

		objects[i].oc_name_idx = objects[i].oc_descr_idx = i;	/* init */
		if (!(objnam = tmpdup(OBJ_NAME(objects[i])))) continue;

		/* make sure probabilities add up to 100000 */
		if(objects[i].oc_class != class) {
			if (sum && sum != 100000) {
			    fprintf(stderr, "prob error for class %d (%d%%)",
				    class, sum);
			    (void) fflush(stderr);
			    sumerr = TRUE;
			}
			class = objects[i].oc_class;
			sum = 0;
		}

		for (c = objnam; *c; c++)
		    if (*c >= 'a' && *c <= 'z') *c -= (char)('a' - 'A');
		    else if (*c < 'A' || *c > 'Z') *c = '_';

		switch (class) {
		    case WAND_CLASS:
			fprintf(ofp,"%s","#define\tWAN_"); prefix = 1; break;
		    case RING_CLASS:
			fprintf(ofp,"%s","#define\tRIN_"); prefix = 1; break;
		    case POTION_CLASS:
			fprintf(ofp,"%s","#define\tPOT_"); prefix = 1; break;
		    case SPBOOK_CLASS:
			fprintf(ofp,"%s","#define\tSPE_"); prefix = 1; nspell++; break;
		    case SCROLL_CLASS:
			fprintf(ofp,"%s","#define\tSCR_"); prefix = 1; break;
		    case AMULET_CLASS:
			/* avoid trouble with stupid C preprocessors */
			fprintf(ofp,"%s","#define\t");
			if(objects[i].oc_material == MT_PLASTIC && objects[i].oc_nutrition == 1) {
			    fprintf(ofp,"FAKE_AMULET_OF_YENDOR\t%d\n", i);
			    prefix = -1;
			    break;
			}
			break;
		    case GEM_CLASS:
			/* avoid trouble with stupid C preprocessors
			 * Amy edit: are those really still being used nowadays??? */
#if 0
			if(objects[i].oc_material == MT_GLASS) {
			    fprintf(ofp,"/* #define\t%s\t%d */\n",
							objnam, i);
			    prefix = -1;
			    break;
			}
#endif
		    default:
			fprintf(ofp,"%s","#define\t");
		}
		if (prefix >= 0)
			fprintf(ofp,"%s\t%d\n", limit(objnam, prefix), i);
		prefix = 0;

		sum += objects[i].oc_prob;
	}

	/* check last set of probabilities */
	if (sum && sum != 100000) {
	    fprintf(stderr, "prob error for class %d (%d%%)", class, sum);
	    (void) fflush(stderr);
	    sumerr = TRUE;
	}

	fprintf(ofp,"%s","#define\tLAST_GEM\t(JADE)\n");
	fprintf(ofp,"#define\tMAXSPELL\t%d\n", nspell+1);
	fprintf(ofp,"#define\tNUM_OBJECTS\t%d\n", i);

	fprintf(ofp,"%s", "\n/* Artifacts (unique objects) */\n\n");

	for (i = 1; artifact_names[i]; i++) {
		SpinCursor(3);

		for (c = objnam = tmpdup(artifact_names[i]); *c; c++)
		    if (*c >= 'a' && *c <= 'z') *c -= (char)('a' - 'A');
		    else if (*c < 'A' || *c > 'Z') *c = '_';

		if (!strncmp(objnam, "THE_", 4))
			objnam += 4;
		/* fudge _platinum_ YENDORIAN EXPRESS CARD */
		if (!strncmp(objnam, "PLATINUM_", 9))
			objnam += 9;
		fprintf(ofp,"#define\tART_%s\t%d\n", limit(objnam, 1), i);
	}

	fprintf(ofp, "#define\tNROFARTIFACTS\t%d\n", i-1);
	fprintf(ofp,"%s","\n#endif /* ONAMES_H */\n");
	fclose(ofp);
	if (sumerr) exit(EXIT_FAILURE);
	return;
}

static char *
tmpdup(str)
const char *str;
{
	static char buf[128];

	if (!str) return (char *)0;
	(void)strncpy(buf, str, 127);
	return buf;
}

static char *
eos(str)
char *str;
{
    while (*str) str++;
    return str;
}

/*
 * macro used to control vision algorithms:
 *      VISION_TABLES => generate tables
 */

void
do_vision()
{
#ifdef VISION_TABLES
    int i, j;

    /* Everything is clear.  xclear may be malloc'ed.
     * Block the upper left corner (BLOCK_HEIGHTxBLOCK_WIDTH)
     */
    for (i = 0; i < MAX_ROW; i++)
	for (j = 0; j < MAX_COL; j++)
	    if (i < BLOCK_HEIGHT && j < BLOCK_WIDTH)
		xclear[i][j] = '\000';
	    else
		xclear[i][j] = '\001';
#endif /* VISION_TABLES */

    SpinCursor(3);

    /*
     * create the include file, "vis_tab.h"
     */
    filename[0]='\0';
#ifdef FILE_PREFIX
    strcat(filename, file_prefix);
#endif
    sprintf(filename, INCLUDE_TEMPLATE, VIS_TAB_H);
    if (!(ofp = fopen(filename, WRTMODE))) {
	perror(filename);
	exit(EXIT_FAILURE);
    }
    fprintf(ofp,"%s",Dont_Edit_Code);
    fprintf(ofp,"%s","#ifdef VISION_TABLES\n");
#ifdef VISION_TABLES
    H_close_gen();
    H_far_gen();
#endif /* VISION_TABLES */
    fprintf(ofp,"%s","\n#endif /* VISION_TABLES */\n");
    fclose(ofp);

    SpinCursor(3);

    /*
     * create the source file, "vis_tab.c"
     */
    filename[0]='\0';
#ifdef FILE_PREFIX
    strcat(filename, file_prefix);
#endif
    sprintf(filename, SOURCE_TEMPLATE, VIS_TAB_C);
    if (!(ofp = fopen(filename, WRTMODE))) {
	perror(filename);
	sprintf(filename, INCLUDE_TEMPLATE, VIS_TAB_H);
	unlink(filename);
	exit(EXIT_FAILURE);
    }
    fprintf(ofp,"%s",Dont_Edit_Code);
    fprintf(ofp,"%s","#include \"config.h\"\n");
    fprintf(ofp,"%s","#ifdef VISION_TABLES\n");
    fprintf(ofp,"%s","#include \"vis_tab.h\"\n");

    SpinCursor(3);

#ifdef VISION_TABLES
    C_close_gen();
    C_far_gen();
    /* KMH -- vis_tab_init() needs prototype */
    fprintf(ofp,"%s", "\nvoid vis_tab_init);\n"(void);
    fprintf(ofp,"%s","\nvoid vis_tab_init() { return; }\n");
#endif /* VISION_TABLES */

    SpinCursor(3);

    fprintf(ofp,"%s","\n#endif /* VISION_TABLES */\n");
    fprintf(ofp,"%s","\n/*vis_tab.c*/\n");

    fclose(ofp);
    return;
}

#ifdef VISION_TABLES

/*--------------  vision tables  --------------*\
 *
 *  Generate the close and far tables.  This is done by setting up a
 *  fake dungeon and moving our source to different positions relative
 *  to a block and finding the first/last visible position.  The fake
 *  dungeon is all clear execpt for the upper left corner (BLOCK_HEIGHT
 *  by BLOCK_WIDTH) is blocked.  Then we move the source around relative
 *  to the corner of the block.  For each new position of the source
 *  we check positions on rows "kittycorner" from the source.  We check
 *  positions until they are either in sight or out of sight (depends on
 *  which table we are generating).  The picture below shows the setup
 *  for the generation of the close table.  The generation of the far
 *  table would switch the quadrants of the '@' and the "Check rows
 *  here".
 *
 *
 *  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
 *  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
 *  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX,,,,,,,,, Check rows here ,,,,,,,,,,,,
 *  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
 *  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXB,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
 *  ...............................
 *  ...............................
 *  .........@.....................
 *  ...............................
 *
 *      Table generation figure (close_table).  The 'X's are blocked points.
 *      The 'B' is a special blocked point.  The '@' is the source.  The ','s
 *      are the target area.  The '.' are just open areas.
 *
 *
 *  Example usage of close_table[][][].
 *
 *  The table is as follows:
 *
 *      dy = |row of '@' - row of 'B'|  - 1
 *      dx = |col of '@' - col of 'B'|
 *
 *  The first indices are the deltas from the source '@' and the block 'B'.
 *  You must check for the value inside the abs value bars being zero.  If
 *  so then the block is on the same row and you don't need to do a table
 *  lookup.  The last value:
 *
 *      dcy = |row of block - row to be checked|
 *
 *  Is the value of the first visible spot on the check row from the
 *  block column.  So
 *
 *  first visible col = close_table[dy][dx][dcy] + col of 'B'
 *
\*--------------  vision tables  --------------*/

static void
H_close_gen()
{
    fprintf(ofp,"%s","\n/* Close */\n");
    fprintf(ofp,"#define CLOSE_MAX_SB_DY %2d\t/* |src row - block row| - 1\t*/\n",
	    TEST_HEIGHT-1);
    fprintf(ofp,"#define CLOSE_MAX_SB_DX %2d\t/* |src col - block col|\t*/\n",
	    TEST_WIDTH);
    fprintf(ofp,"#define CLOSE_MAX_BC_DY %2d\t/* |block row - check row|\t*/\n",
	    TEST_HEIGHT);
    fprintf(ofp,"%s","typedef struct {\n");
    fprintf(ofp,"%s","    unsigned char close[CLOSE_MAX_SB_DX][CLOSE_MAX_BC_DY];\n");
    fprintf(ofp,"%s","} close2d;\n");
    fprintf(ofp,"%s","extern close2d close_table[CLOSE_MAX_SB_DY];\n");
    return;
}

static void
H_far_gen()
{
    fprintf(ofp,"%s","\n/* Far */\n");
    fprintf(ofp,"#define FAR_MAX_SB_DY %2d\t/* |src row - block row|\t*/\n",
	    TEST_HEIGHT);
    fprintf(ofp,"#define FAR_MAX_SB_DX %2d\t/* |src col - block col| - 1\t*/\n",
	    TEST_WIDTH-1);
    fprintf(ofp,"#define FAR_MAX_BC_DY %2d\t/* |block row - check row| - 1\t*/\n",
	    TEST_HEIGHT-1);
    fprintf(ofp,"%s","typedef struct {\n");
    fprintf(ofp,"%s","    unsigned char far_q[FAR_MAX_SB_DX][FAR_MAX_BC_DY];\n");
    fprintf(ofp,"%s","} far2d;\n");
    fprintf(ofp,"%s","extern far2d far_table[FAR_MAX_SB_DY];\n");
    return;
}

static void
C_close_gen()
{
    int i,dx,dy;
    int src_row, src_col;	/* source */
    int block_row, block_col;	/* block */
    int this_row;
    int no_more;
    const char *delim;

    block_row = BLOCK_HEIGHT-1;
    block_col = BLOCK_WIDTH-1;

    fprintf(ofp,"%s","\n#ifndef FAR_TABLE_ONLY\n");
    fprintf(ofp,"%s","\nclose2d close_table[CLOSE_MAX_SB_DY] = {\n");
#ifndef no_vision_progress
    fprintf(stderr,"%s","\nclose:");
#endif

    for (dy = 1; dy < TEST_HEIGHT; dy++) {
	src_row = block_row + dy;
	fprintf(ofp, "/* DY = %2d (- 1)*/\n  {{\n", dy);
#ifndef no_vision_progress
	fprintf(stderr," %2d",dy),  (void)fflush(stderr);
#endif
	for (dx = 0; dx < TEST_WIDTH; dx++) {
	    src_col = block_col - dx;
	    fprintf(ofp, "  /*%2d*/ {", dx);

	    no_more = 0;
	    for (this_row = 0; this_row < TEST_HEIGHT; this_row++) {
		delim = (this_row < TEST_HEIGHT - 1) ? "," : "";
		if (no_more) {
		    fprintf(ofp, "%s%s", CLOSE_OFF_TABLE_STRING, delim);
		    continue;
		}
		SpinCursor(3);

		/* Find the first column that we can see. */
		for (i = block_col+1; i < MAX_COL; i++) {
		    if (clear_path(src_row,src_col,block_row-this_row,i))
			break;
		}

		if (i == MAX_COL) no_more = 1;
		fprintf(ofp, "%2d%s", i - block_col, delim);
	    }
	    fprintf(ofp, "}%s", (dx < TEST_WIDTH - 1) ? ",\n" : "\n");
	}
	fprintf(ofp,"  }},\n");
    }

    fprintf(ofp,"%s","}; /* close_table[] */\n");		/* closing brace for table */
    fprintf(ofp,"%s","#endif /* !FAR_TABLE_ONLY */\n");
#ifndef no_vision_progress
    fprintf(stderr,"%s","\n");
#endif
    return;
}

static void
C_far_gen()
{
    int i,dx,dy;
    int src_row, src_col;	/* source */
    int block_row, block_col;	/* block */
    int this_row;
    const char *delim;

    block_row = BLOCK_HEIGHT-1;
    block_col = BLOCK_WIDTH-1;

    fprintf(ofp,"%s","\n#ifndef CLOSE_TABLE_ONLY\n");
    fprintf(ofp,"%s","\nfar2d far_table[FAR_MAX_SB_DY] = {\n");
#ifndef no_vision_progress
    fprintf(stderr,"%s","\n_far_:");
#endif

    for (dy = 0; dy < TEST_HEIGHT; dy++) {
	src_row = block_row - dy;
	fprintf(ofp, "/* DY = %2d */\n  {{\n", dy);
#ifndef no_vision_progress
	fprintf(stderr," %2d",dy),  (void)fflush(stderr);
#endif
	for (dx = 1; dx < TEST_WIDTH; dx++) {
	    src_col = block_col + dx;
	    fprintf(ofp, "  /*%2d(-1)*/ {", dx);

	    for (this_row = block_row+1; this_row < block_row+TEST_HEIGHT;
								this_row++) {
		delim = (this_row < block_row + TEST_HEIGHT - 1) ? "," : "";

		SpinCursor(3);
		/* Find first col that we can see. */
		for (i = 0; i <= block_col; i++) {
		    if (clear_path(src_row,src_col,this_row,i)) break;
		}

		if (block_col-i < 0)
		    fprintf(ofp, "%s%s", FAR_OFF_TABLE_STRING, delim);
		else
		    fprintf(ofp, "%2d%s", block_col - i, delim);
	    }
	    fprintf(ofp, "}%s", (dx < TEST_WIDTH - 1) ? ",\n" : "\n");
	}
	fprintf(ofp,"  }},\n");
    }

    fprintf(ofp,"%s","}; /* far_table[] */\n");	/* closing brace for table */
    fprintf(ofp,"%s","#endif /* !CLOSE_TABLE_ONLY */\n");
#ifndef no_vision_progress
    fprintf(stderr,"%s","\n");
#endif
    return;
}

/*
 *  "Draw" a line from the hero to the given location.  Stop if we hit a
 *  wall.
 *
 *  Generalized integer Bresenham's algorithm (fast line drawing) for
 *  all quadrants.  From _Procedural Elements for Computer Graphics_, by
 *  David F. Rogers.  McGraw-Hill, 1985.
 *
 *  I have tried a little bit of optimization by pulling compares out of
 *  the inner loops.
 *
 *  NOTE:  This had better *not* be called from a position on the
 *  same row as the hero.
 */
static int
clear_path(you_row,you_col,y2,x2)
    int you_row, you_col, y2, x2;
{
    int dx, dy, s1, s2;
    register int i, error, x, y, dxs, dys;

    x  = you_col;		y  = you_row;
    dx = abs(x2-you_col);	dy = abs(y2-you_row);
    s1 = sign(x2-you_col);	s2 = sign(y2-you_row);

    if (s1 == 0) {	/* same column */
	if (s2 == 1) {	/* below (larger y2 value) */
	    for (i = you_row+1; i < y2; i++)
		if (!xclear[i][you_col]) return 0;
	} else {	/* above (smaller y2 value) */
	    for (i = y2+1; i < you_row; i++)
		if (!xclear[i][you_col]) return 0;
	}
	return 1;
    }

    /*
     *  Lines at 0 and 90 degrees have been weeded out.
     */
    if (dy > dx) {
	error = dx; dx = dy; dy = error;	/* swap the values */
	dxs = dx << 1;		/* save the shifted values */
	dys = dy << 1;
	error = dys - dx;	/* NOTE: error is used as a temporary above */

	for (i = 0; i < dx; i++) {
	    if (!xclear[y][x]) return 0;	/* plot point */

	    while (error >= 0) {
		x += s1;
		error -= dxs;
	    }
	    y += s2;
	    error += dys;
	}
    } else {
	dxs = dx << 1;		/* save the shifted values */
	dys = dy << 1;
	error = dys - dx;

	for (i = 0; i < dx; i++) {
	    if (!xclear[y][x]) return 0;	/* plot point */

	    while (error >= 0) {
		y += s2;
		error -= dxs;
	    }
	    x += s1;
	    error += dys;
	}
    }
    return 1;
}
#endif /* VISION_TABLES */


/* KMH -- Now supports upper, lower, and mixed case filenames */
void
do_filenames()
{
	char    *infile;
	int i;
	char buf[BUFSZ];
	char lname[20] = DEF_GAME_NAME;
	char uname[20] = DEF_GAME_NAME;

	infile = malloc(strlen(INCLUDE_TEMPLATE) - 2 + strlen(FILE_H) + 1);
	(void) lcase(lname);
	(void) ucase(uname);

    /*
     * create the source file, "filename.h"
     */
    filename[0]='\0';
#ifdef FILE_PREFIX
    strcat(filename, file_prefix);
#endif

    sprintf(eos(filename), INCLUDE_TEMPLATE, FILENAME_H);
    if (!(ofp = fopen(filename, WRTMODE))) {
		perror(filename);
		exit(EXIT_FAILURE);
    }
    fprintf(ofp,"%s","/*\tSCCS Id: @(#)filename.h\t3.2\t96/05/17 */\n\n");
    fprintf(ofp,"%s",Dont_Edit_Code);

/*OPEN file*/
    sprintf(infile, INCLUDE_TEMPLATE, FILE_H);
    if (!(ifp = fopen(infile, RDTMODE))) {
        perror(infile);
        fclose(ofp);
        unlink(filename);       /* kill empty output file */
        exit(EXIT_FAILURE);
     }
     free(infile);
     do {
        fgets(in_line, sizeof in_line, ifp);
        if (*in_line != '#') continue;
                sscanf(in_line, "# %s", buf);
     } while (strcmp(buf, "START") != 0);
     while (fgets(in_line, sizeof in_line, ifp)) {
        for ( i = 0; i < strlen(in_line);  i++ ) {
           if (in_line[i] == '@') {
/*differentiate uppercase, lowercase*/
/*assume DEF_GAME_NAME is uppercase*/
/* KMH -- Added mixed case */
                if ((in_line[i+1] == 'l') || (in_line[i+1] == 'L'))
                        (void) fputs(lname,ofp);
                else if ((in_line[i+1] == 'u') || (in_line[i+1] == 'U'))
                        (void) fputs(uname,ofp);
                else
                        (void) fputs(DEF_GAME_NAME,ofp);                
                i=i+6;
                }
           else (void) fputc(in_line[i], ofp);
        }
     }
     fclose(ifp);
     fclose(ofp);
     return;
}


char *
lcase(s)		/* convert a string into all lowercase */
    char *s;
{
    register char *p;

    for (p = s; *p; p++)
		if ('A' <= *p && *p <= 'Z') *p |= 040;
    return s;
}


/* KMH -- added function */
char *
ucase(s)		/* convert a string into all lowercase */
    char *s;
{
    register char *p;

    for (p = s; *p; p++)
		if ('a' <= *p && *p <= 'z') *p &= ~040;
    return s;
}


#ifdef STRICT_REF_DEF
NEARDATA struct flag flags;
# ifdef ATTRIB_H
struct attribs attrmax, attrmin;
# endif
#endif /* STRICT_REF_DEF */

/*makedefs.c*/
